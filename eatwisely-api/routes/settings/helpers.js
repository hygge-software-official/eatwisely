import {
  UpdateItemCommand,
  DescribeTableCommand,
  GetItemCommand,
  PutItemCommand,
} from '@aws-sdk/client-dynamodb';
import {
  BatchWriteCommand,
  DynamoDBDocumentClient,
  GetCommand,
  QueryCommand,
} from '@aws-sdk/lib-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';
import * as Sentry from '@sentry/aws-serverless';
import { client } from '../../utils/dynamoDB.js';

import { errorHandlerSentry } from '../../utils/errorHandlerSentry.js';

import { USER_RECIPES_TABLE, USER_SETTINGS_TABLE } from '../../utils/config.js';

const docClient = DynamoDBDocumentClient.from(client);

export const setConnectsForUser = async (userId, connectsToAdd) => {
  try {
    const getParams = {
      TableName: USER_SETTINGS_TABLE,
      Key: marshall({ userId }),
    };

    const existingUser = await client.send(new GetItemCommand(getParams));

    if (!existingUser.Item) {
      console.warn(
        `User settings not found for user ${userId}. Creating new entry.`
      );
      const putParams = {
        TableName: USER_SETTINGS_TABLE,
        Item: marshall({
          userId,
          connects: connectsToAdd,
          initialConnects: connectsToAdd,
        }),
      };

      await client.send(new PutItemCommand(putParams));
      return {
        userId,
        connects: connectsToAdd,
        initialConnects: connectsToAdd,
        created: true,
      };
    }

    const userSettings = unmarshall(existingUser.Item);
    const currentConnects = userSettings.connects || 0;

    let currentInitialConnects = userSettings.initialConnects;
    if (currentInitialConnects === undefined) {
      currentInitialConnects = currentConnects;
    }

    const newConnects = currentConnects + connectsToAdd;
    const newInitialConnects = newConnects;

    const updateParams = {
      TableName: USER_SETTINGS_TABLE,
      Key: marshall({ userId }),
      UpdateExpression:
        'SET initialConnects = :newInitialConnects, connects = :newConnects',
      ExpressionAttributeValues: marshall({
        ':newInitialConnects': newInitialConnects,
        ':newConnects': newConnects,
      }),
      ReturnValues: 'ALL_NEW',
    };

    const { Attributes } = await client.send(
      new UpdateItemCommand(updateParams)
    );
    return unmarshall(Attributes);
  } catch (error) {
    console.error(`Error updating connects for user ${userId}:`, error);
    Sentry.captureException(`Failed to update connects for user ${userId}`);
    throw new Error(`Failed to update connects for user ${userId}`);
  }
};

export async function checkTableExists(tableName) {
  try {
    const command = new DescribeTableCommand({ TableName: tableName });
    await client.send(command);
    return true;
  } catch (error) {
    if (error.name === 'ResourceNotFoundException') {
      return false;
    }
    throw error;
  }
}

export const handleError = (res, error, message, statusCode = 500) => {
  console.error(message, error);
  errorHandlerSentry(res, error, message, statusCode);
};

export const checkUserIdAndTable = async (userId, res) => {
  if (!userId) {
    return handleError(res, 'userId is required');
  }

  try {
    const tableExists = await checkTableExists(USER_SETTINGS_TABLE);
    if (!tableExists) {
      Sentry.captureException(`Table ${USER_SETTINGS_TABLE} not found`);
      throw new Error(`Table ${USER_SETTINGS_TABLE} not found`);
    }

    return true;
  } catch (error) {
    res.status(404).json({ error: error.message });
    return false;
  }
};

/**
 * Retrieves the user settings from the UserSettings table.
 * @param {string} userId - The user ID.
 * @returns {object} The user settings.
 */
export async function getUserSettings(userId) {
  const getParams = {
    TableName: USER_SETTINGS_TABLE,
    Key: { userId },
  };

  const { Item } = await docClient.send(new GetCommand(getParams));

  if (!Item) {
    console.log(
      `No settings found for user ${userId}, initializing with default values.`
    );
    Sentry.captureException(
      `No settings found for user ${userId}, initializing with default values.`
    );
    return {
      allergies: [],
      diet: '',
      goal: '',
      dislikes: [],
      excludeTitles: [],
      connects: 0,
      initialConnects: 0,
      userId,
      feedbackSubmitted: false,
    };
  }

  return {
    allergies: Item.allergies || [],
    diet: Item.diet || '',
    goal: Item.goal || '',
    dislikes: Item.dislikes || [],
    excludeTitles: Item.excludeTitles || [],
    connects: Item.connects || 0,
    initialConnects: Item.initialConnects || 0,
    userId: Item.userId,
    feedbackSubmitted: Item.feedbackSubmitted === true,
  };
}

/**
 * Retrieves the count of recipes generated by the user from the UserRecipes table.
 * @param {string} userId - The user ID.
 * @returns {number} The count of recipes generated by the user.
 */
export async function getUserRecipeCount(userId) {
  const queryParams = {
    TableName: USER_RECIPES_TABLE,
    KeyConditionExpression: 'userId = :userId',
    ExpressionAttributeValues: {
      ':userId': userId,
    },
    Select: 'COUNT',
  };

  const { Count } = await docClient.send(new QueryCommand(queryParams));

  return Count || 0;
}

export async function getEndpointArnForUser(userId) {
  try {
    const params = {
      TableName: USER_SETTINGS_TABLE,
      Key: {
        userId: { S: userId },
      },
      ProjectionExpression: 'endpointArn',
    };

    const response = await client.send(new GetItemCommand(params));

    if (response.Item && response.Item.endpointArn) {
      return response.Item.endpointArn.S; // Повертаємо значення рядка
    }

    return null;
  } catch (error) {
    Sentry.captureException(`Error retrieving endpoint ARN ${error}`);
    console.error('Error retrieving endpoint ARN:', error);
    throw error;
  }
}

/**
 * Retrieves all recipes generated by the user from the UserRecipes table.
 * @param {string} userId - The user ID.
 * @returns {Array<Object>} The list of recipes generated by the user.
 */

export async function getUserRecipes(userId) {
  const queryParams = {
    TableName: USER_RECIPES_TABLE,
    KeyConditionExpression: 'userId = :userId',
    ExpressionAttributeValues: {
      ':userId': userId,
    },
  };

  try {
    const { Items } = await docClient.send(new QueryCommand(queryParams));
    return Items || [];
  } catch (error) {
    console.error('Error querying user recipes:', error);
    throw error;
  }
}

/**
 * Deletes all recipes generated by the user from the UserRecipes table.
 * @param {string} userId - The user ID.
 * @returns {Promise<void>}
 */
export async function deleteUserRecipes(userId) {
  const items = await getUserRecipes(userId);

  if (items.length === 0) {
    console.log('No recipes found for user:', userId);
    return;
  }

  const chunkSize = 25; // Максимальна кількість елементів для одного BatchWrite запиту
  for (let i = 0; i < items.length; i += chunkSize) {
    const chunk = items.slice(i, i + chunkSize);

    const deleteRequests = chunk.map(item => ({
      DeleteRequest: {
        Key: {
          userId: item.userId,
          recipeId: item.recipeId,
        },
      },
    }));

    const batchWriteParams = {
      RequestItems: {
        [USER_RECIPES_TABLE]: deleteRequests,
      },
    };

    try {
      await docClient.send(new BatchWriteCommand(batchWriteParams));
      console.log(`Deleted recipes ${i + 1} to ${i + chunk.length}`);
    } catch (error) {
      console.error(
        `Error deleting recipes ${i + 1} to ${i + chunk.length}:`,
        error
      );
      throw error;
    }
  }

  console.log('All user recipes deleted successfully');
}

export async function updateUserSettings(userId, updates) {
  const updateExpression =
    'SET ' +
    Object.keys(updates)
      .map(key => `#${key} = :${key}`)
      .join(', ');
  const expressionAttributeNames = Object.keys(updates).reduce(
    (acc, key) => ({ ...acc, [`#${key}`]: key }),
    {}
  );
  const expressionAttributeValues = Object.entries(updates).reduce(
    (acc, [key, value]) => {
      if (Array.isArray(value)) {
        return { ...acc, [`:${key}`]: { L: value.map(item => ({ S: item })) } };
      } else if (typeof value === 'string') {
        return { ...acc, [`:${key}`]: { S: value } };
      } else {
        return { ...acc, [`:${key}`]: { S: JSON.stringify(value) } };
      }
    },
    {}
  );

  const params = {
    TableName: USER_SETTINGS_TABLE,
    Key: marshall({ userId }),
    UpdateExpression: updateExpression,
    ExpressionAttributeNames: expressionAttributeNames,
    ExpressionAttributeValues: expressionAttributeValues,
    ReturnValues: 'ALL_NEW',
  };

  const { Attributes } = await client.send(new UpdateItemCommand(params));
  return unmarshall(Attributes);
}

export async function subtractConnects(userId, subtractCount) {
  const getUserParams = {
    TableName: USER_SETTINGS_TABLE,
    Key: marshall({ userId }),
    ProjectionExpression: 'connects',
  };
  const { Item } = await client.send(new GetItemCommand(getUserParams));
  if (!Item) {
    return { error: 'User not found' };
  }

  const userSettings = unmarshall(Item);
  let currentConnects = userSettings.connects || 0;
  if (currentConnects <= 0) {
    return { error: 'No connects left' };
  }

  const newConnects = currentConnects - parseInt(subtractCount, 10);
  if (newConnects < 0) {
    return { error: 'Not enough connects', currentConnects };
  }

  const updateParams = {
    TableName: USER_SETTINGS_TABLE,
    Key: marshall({ userId }),
    UpdateExpression: 'SET connects = :newConnects',
    ExpressionAttributeValues: marshall({ ':newConnects': newConnects }),
    ReturnValues: 'ALL_NEW',
  };

  const { Attributes } = await client.send(new UpdateItemCommand(updateParams));
  return unmarshall(Attributes);
}
